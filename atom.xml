<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>岭南小生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-09T01:51:43.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/11/09/hello-world/"/>
    <id>http://yoursite.com/2019/11/09/hello-world/</id>
    <published>2019-11-09T01:51:43.290Z</published>
    <updated>2019-11-09T01:51:43.290Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BeautifulSoup学习笔记</title>
    <link href="http://yoursite.com/2018/04/09/1/"/>
    <id>http://yoursite.com/2018/04/09/1/</id>
    <published>2018-04-09T01:54:30.000Z</published>
    <updated>2019-11-09T15:16:34.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">笑问纷纭乱世，何处远大前程</blockquote>​    [Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/) 是一个可以从HTML或XML文件中提取数据的Python库。<a id="more"></a><p>#对象的种类</p><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag，NavigableString，BeautifulSoup，Comment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(&apos;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&apos;)</span><br><span class="line">tag = soup.b</span><br><span class="line"></span><br><span class="line">tag.name</span><br><span class="line"># u&apos;b&apos;</span><br><span class="line"></span><br><span class="line">tag[&apos;class&apos;]</span><br><span class="line"># u&apos;boldest&apos;</span><br><span class="line"></span><br><span class="line">tag.attrs</span><br><span class="line"># &#123;u&apos;class&apos;: u&apos;boldest&apos;&#125;</span><br><span class="line"></span><br><span class="line">tag.string</span><br><span class="line"># u&apos;Extremely bold&apos;</span><br></pre></td></tr></table></figure><h1 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>获取 <head> 标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.head</span><br><span class="line"># &lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">soup.title</span><br><span class="line"># &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br><span class="line">通过点取属性的方式只能获得当前名字的第一个tag:</span><br><span class="line">soup.a</span><br><span class="line"># &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>tag的 .contents 属性可以将tag的子节点以列表的方式输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">head_tag = soup.head</span><br><span class="line">head_tag.contents</span><br><span class="line">[&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</span><br><span class="line">字符串没有 .contents 属性,因为字符串没有子节点</span><br><span class="line">head_tag.string</span><br><span class="line"># u&apos;The Dormouse&apos;s story&apos;</span><br></pre></td></tr></table></figure><p>tag中包含多个字符串,可以使用 .strings 来循环获取<br>输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings可以去除多余空白内容</p><p>通过 .parent 属性来获取某个元素的父节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title_tag = soup.title</span><br><span class="line">title_tag.string.parent</span><br><span class="line"># &lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;</span><br></pre></td></tr></table></figure><p>兄弟节点，使用.next_sibling 和.previous_sibling 属性来查询兄弟节点<br>通过.next_siblings 和.previous_siblings 属性可以对当前节点的兄弟节点迭代输出</p><h1 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h1><h2 id="find-all-、find-方法"><a href="#find-all-、find-方法" class="headerlink" title="find_all()、find()方法"></a>find_all()、find()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find_all(name=None, attrs=&#123;&#125;, recursive=True, text=None, **kwargs)  返回一个列表</span><br><span class="line">Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False</span><br><span class="line"></span><br><span class="line">soup.find_all(&quot;p&quot;, &quot;title&quot;)</span><br><span class="line"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;]</span><br><span class="line"></span><br><span class="line">soup.find_all(id=&quot;link2&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br><span class="line"></span><br><span class="line">#如果传入 href 参数,Beautiful Soup会搜索每个tag的”href”属性:</span><br><span class="line">soup.find_all(href=re.compile(&quot;elsie&quot;), id=&apos;link1&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;]</span><br><span class="line"></span><br><span class="line">#匹配多值属性情况，如a标签class有两个属性值</span><br><span class="line">items = soup.find_all(&apos;a&apos;,attrs=&#123;&apos;class&apos;:&apos;dd xx&apos;&#125;)</span><br><span class="line">for i in items:</span><br><span class="line">    idl = i.get(&apos;href&apos;)   #get函数获取href链接值</span><br></pre></td></tr></table></figure><p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容<br>下面例子中找出所有以b开头的标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for tag in soup.find_all(re.compile(&quot;^b&quot;)):</span><br><span class="line">    print(tag.name)</span><br><span class="line"># body</span><br><span class="line"># b</span><br></pre></td></tr></table></figure><p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有<a>标签和<b>标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all([&quot;a&quot;, &quot;b&quot;])</span><br><span class="line"># [&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></pre></td></tr></table></figure><p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数，如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def has_class_but_no_id(tag):</span><br><span class="line">    return tag.has_attr(&apos;class&apos;) and not tag.has_attr(&apos;id&apos;)</span><br><span class="line">将这个方法作为参数传入 find_all() 方法,将得到所有&lt;p&gt;标签:    </span><br><span class="line">soup.find_all(has_class_but_no_id)</span><br><span class="line"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;,</span><br><span class="line">#  &lt;p class=&quot;story&quot;&gt;Once upon a time there were...&lt;/p&gt;,</span><br><span class="line">#  &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span><br></pre></td></tr></table></figure><h2 id="按照CSS搜索"><a href="#按照CSS搜索" class="headerlink" title="按照CSS搜索"></a>按照CSS搜索</h2><p>标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误。从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)</span><br><span class="line">soup.find_all(class_=re.compile(&quot;itl&quot;))</span><br></pre></td></tr></table></figure><p>通过text参数可以搜搜文档中的字符串内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, text=&quot;Elsie&quot;)</span><br><span class="line"># [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br><span class="line"></span><br><span class="line">使用 limit 参数限制返回结果的数量</span><br><span class="line">soup.find_all(&quot;a&quot;, limit=2)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></pre></td></tr></table></figure><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>Beautiful Soup支持大部分的CSS选择器,在Tag或 BeautifulSoup 对象的 .select()方法中传入字符串参数,即可使用CSS选择器的语法找到tag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过tag标签逐层查找:</span><br><span class="line">soup.select(&quot;head &gt; title&quot;)</span><br><span class="line">找到兄弟节点标签:</span><br><span class="line">soup.select(&quot;#link1 + .sister&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br><span class="line">通过CSS的类名查找:</span><br><span class="line">soup.select(&quot;.sister&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;...</span><br><span class="line">通过是否存在某个属性来查找:</span><br><span class="line">soup.select(&apos;a[href]&apos;)</span><br></pre></td></tr></table></figure><h1 id="编码及输出"><a href="#编码及输出" class="headerlink" title="编码及输出"></a>编码及输出</h1><p>任何HTML或XML文档都有自己的编码方式,比如ASCII或 UTF-8,但是使用Beautiful Soup解析后,文档都被转换成了Unicode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup(&quot;Sacr&amp;eacute; bleu!&quot;)</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>输出时，调用 BeautifulSoup对象或任意节点的 encode() 方法，转换为str类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.p.encode(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure><p>编码自动检测功能可以在Beautiful Soup以外使用,检测某段未知编码时,可以使用这个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import UnicodeDammit</span><br><span class="line">dammit = UnicodeDammit(&quot;Sacr\xc3\xa9 bleu!&quot;)</span><br><span class="line">print(dammit.unicode_markup)</span><br><span class="line"># Sacré bleu!</span><br><span class="line">dammit.original_encoding</span><br><span class="line"># &apos;utf-8&apos;</span><br><span class="line"></span><br><span class="line">其它检测方法：chardet 或 cchardet</span><br></pre></td></tr></table></figure><p>prettify() 方法将Beautiful Soup的文档树格式化后以Unicode编码输出，每个XML/HTML标签都独占一行，BeautifulSoup对象和它的tag节点都可以调用 prettify() 方法</p><p>如果只想得到结果字符串,不重视格式,那么可以对一个 BeautifulSoup 对象或 Tag 对象使用Python的 unicode() 或 str()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str(soup)</span><br><span class="line"># &apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">unicode(soup.a)</span><br><span class="line"># u&apos;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&apos;</span><br></pre></td></tr></table></figure><p>str() 方法返回UTF-8编码的字符串,可以指定 编码 的设置<br>还可以调用 encode() 方法获得字节码或调用 decode() 方法获得Unicode</p><p>如果只想得到tag中包含的文本内容,那么可以嗲用 get_text()方法，还可以去除获得文本内容的前后空白:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.title.get_text(strip=True)</span><br><span class="line">u&apos;The Dormouse&apos;s story&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;笑问纷纭乱世，何处远大前程&lt;/blockquote&gt;
​    [Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/) 是一个可以从HTML或XML文件中提取数据的Python库。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git版本控制</title>
    <link href="http://yoursite.com/2018/04/02/1/"/>
    <id>http://yoursite.com/2018/04/02/1/</id>
    <published>2018-04-02T14:36:53.000Z</published>
    <updated>2019-11-09T15:17:16.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">努力吧！趁阳光正好，趁微风不噪，趁花儿还未开到荼靡</blockquote>​    其它大部分工具以文件变更列表的方式存储信息。而Git不同，每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。<a id="more"></a><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。<br>已提交表示数据已经安全的保存在本地数据库中。<br>已修改表示修改了文件，但还没保存到数据库中。<br>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域</p><p><img src="/Users/longhui.he/GithubBlog/source/upload_image/2018-04-01/7909.jpg" alt=""></p><p>工作区：就是你在电脑里能看到的目录<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h2><p>1、创建一个文件夹，进入该文件夹后使用 <strong>git init</strong> 命令来初始化一个 Git 仓库</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &apos;初始化项目版本&apos;</span><br></pre></td></tr></table></figure><p>2、使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; [directory]</span><br><span class="line">如：git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>如果不重命名文件夹，默认执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录</p><p>另外几种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CosmosHua/locate [new目录]</span><br><span class="line">git clone https://github.com/CosmosHua/locate.git [new目录]</span><br><span class="line">git clone git://github.com/CosmosHua/locate [new目录]</span><br><span class="line">git clone git://github.com/CosmosHua/locate.git [new目录]</span><br></pre></td></tr></table></figure><h2 id="基本快照"><a href="#基本快照" class="headerlink" title="基本快照"></a>基本快照</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比</p><h3 id="git-add添加、修改"><a href="#git-add添加、修改" class="headerlink" title="git add添加、修改"></a>git add添加、修改</h3><p>git add 命令可将该文件添加到缓存，如我们添加以下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello.php</span><br><span class="line">$ git status -s</span><br><span class="line">?? hello.php</span><br></pre></td></tr></table></figure><p>git status 命令用于查看项目的当前状态。接下来我们执行 git add 命令来添加文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.php </span><br><span class="line">$ git status -s</span><br><span class="line">A  hello.php</span><br></pre></td></tr></table></figure><p>现在修改hello.php后，再查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">AM  hello.php</span><br></pre></td></tr></table></figure><p>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。执行 git add . 命令将改动后添加到缓存中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git status -s</span><br><span class="line">A  hello.php</span><br></pre></td></tr></table></figure><h3 id="git-diff查看缓存"><a href="#git-diff查看缓存" class="headerlink" title="git diff查看缓存"></a>git diff查看缓存</h3><p>git diff 命令显示：已写入缓存与已修改但尚未写入缓存的改动的区别（查看尚未暂存的文件更新了哪些部分）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">尚未缓存的改动：git diff</span><br><span class="line">查看已缓存的改动： git diff --cached</span><br><span class="line">查看已缓存的与未缓存的所有改动：git diff HEAD</span><br><span class="line">显示摘要而非整个 diff：git diff --stat</span><br></pre></td></tr></table></figure><h3 id="git-reset-HEAD取消缓存"><a href="#git-reset-HEAD取消缓存" class="headerlink" title="git reset HEAD取消缓存"></a>git reset HEAD取消缓存</h3><p>git reset HEAD 命令用于取消已缓存的内容，如取消已缓存的hello.php文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- hello.php</span><br></pre></td></tr></table></figure><h3 id="git-commit提交改动"><a href="#git-commit提交改动" class="headerlink" title="git commit提交改动"></a>git commit提交改动</h3><p> git commit 将缓存区内容添加到本地仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;第一次版本提交&apos;</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。</p><p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &apos;修改 hello.php 文件&apos;</span><br></pre></td></tr></table></figure><h3 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br><span class="line">如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span><br><span class="line">git rm -f &lt;file&gt;</span><br><span class="line">如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除</span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line">可以递归删除，即如果后面跟的是一个目录做为参数</span><br><span class="line">git rm –r *</span><br></pre></td></tr></table></figure><p>如果某些文件已经push到github，那如何删除？</p><p>首先，把这个文件从暂存区域移除（如移除.idea文件夹下所有文件）：git rm –cached -r .idea</p><p>第二，将缓存区内容添加到本地仓库，即更新本地仓库：git commit -m “remove some file”</p><p>第三，将本地仓库重新push到github：git push -u origin master</p><h3 id="git-mv移动"><a href="#git-mv移动" class="headerlink" title="git mv移动"></a>git mv移动</h3><p>git mv 命令用于移动或重命名一个文件、目录、软连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv README  README.md</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)    #创建分支</span><br><span class="line">git checkout (branchname)  #切换分支</span><br><span class="line">git merge      #合并分支</span><br><span class="line">git branch     #列出分支</span><br><span class="line">git branch -d (branchname)  #删除分支</span><br></pre></td></tr></table></figure><p>也可以使用 git checkout -b (branchname)  命令来创建新分支并立即切换到该分支下；当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了”testing”分支，Git 将还原你的工作目录到你创建分支时候的样子</p><p>#提交至远程仓库</p><h2 id="查看、配置远程仓库"><a href="#查看、配置远程仓库" class="headerlink" title="查看、配置远程仓库"></a>查看、配置远程仓库</h2><p>查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/rank0/my_projects.git (fetch)</span><br><span class="line">origin  https://github.com/rank0/my_projects.git (push)</span><br></pre></td></tr></table></figure><p>如果没有就添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br><span class="line">git remote add origin https://github.com/rank0/my_projects.git</span><br><span class="line"># 添加仓库 origin2</span><br><span class="line">git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line"># 删除仓库 origin2</span><br><span class="line">$ git remote rm origin2</span><br></pre></td></tr></table></figure><h2 id="提取远程仓库"><a href="#提取远程仓库" class="headerlink" title="提取远程仓库"></a>提取远程仓库</h2><p>git两个命令用来提取远程仓库的更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch    #从远程仓库下载新分支与数据</span><br><span class="line">$ git fetch origin</span><br><span class="line">git merge    #从远端仓库提取数据并尝试合并到当前分支</span><br><span class="line">$ git merge origin/master</span><br></pre></td></tr></table></figure><p>首先执行 git fetch [alias]告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><h2 id="push到远程仓库"><a href="#push到远程仓库" class="headerlink" title="push到远程仓库"></a>push到远程仓库</h2><p>推送你的新分支与数据到某个远端仓库命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push [alias] [branch]</span><br><span class="line">$ git push -u origin master    # 推送到 Github</span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-tutorial.html</a><br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;努力吧！趁阳光正好，趁微风不噪，趁花儿还未开到荼靡&lt;/blockquote&gt;
​    其它大部分工具以文件变更列表的方式存储信息。而Git不同，每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python2编码总结</title>
    <link href="http://yoursite.com/2018/04/01/1/"/>
    <id>http://yoursite.com/2018/04/01/1/</id>
    <published>2018-04-01T02:11:06.000Z</published>
    <updated>2019-11-09T15:17:34.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">秃废是糖，甜到忧伤</blockquote>​    Python2 编码问题一直困扰了很久，编程过程中经常因为编码问题报错或出现乱码，现对该知识点进行总结。编码问题主要注意的点：系统默认编码、str与unicode之间转换、windows/linux控制台默认编码。从外界获取的中文一般为str类型，在代码内部建议全部使用unicode编码，在获取外部内容时，先decode为unicode，向外输出时再encode为Str<a id="more"></a><h1 id="编码基础"><a href="#编码基础" class="headerlink" title="编码基础"></a>编码基础</h1><p>ASCII编码，使用一个字节即8个比特位，8个比特位可以表示256个符号；最开始ASCII只定义了128个字符编码，，因此 ASCII 只使用了一个字节的后7位，最高位都为0。</p><p>CP437编码，是 Windows 系统中使用的字符编码</p><p>GBK编码，GBK 不仅收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。同样 GBK 也是兼容 ASCII 编码的，对于英文字符用1个字节来表示，汉字用两个字节来标识。</p><p>Unicode编码，国际组织提出的统一编码；Unicode编码有不同的实现方式，比如：UTF-8、UTF-16等等</p><p>UTF-8编码，作为Unicode的一种实现方式；它是一种变长的字符编码，可以根据具体情况用1-4个字节来表示一个字符</p><p>查看windows、linux各编码情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print sys.getdefaultencoding()    #系统默认编码</span><br><span class="line">print sys.getfilesystemencoding() #文件系统编码</span><br><span class="line">print locale.getdefaultlocale()   #系统当前编码</span><br><span class="line">print sys.stdin.encoding          #终端输入编码</span><br><span class="line">print sys.stdout.encoding         #终端输出编码</span><br></pre></td></tr></table></figure><p>windows输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ascii</span><br><span class="line">mbcs</span><br><span class="line">(&apos;zh_CN&apos;, &apos;cp936&apos;)</span><br><span class="line">cp936</span><br><span class="line">cp936</span><br></pre></td></tr></table></figure><p>liunx输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ascii</span><br><span class="line">UTF-8</span><br><span class="line">(&apos;zh_CN&apos;, &apos;UTF-8&apos;)</span><br><span class="line">UTF-8</span><br><span class="line">UTF-8</span><br></pre></td></tr></table></figure><p>可以到看出windows与linux下系统默认都为ascii编码，而ascii编码不支持中文</p><h2 id="操作系统编码引起报错"><a href="#操作系统编码引起报错" class="headerlink" title="操作系统编码引起报错"></a>操作系统编码引起报错</h2><p>写爬虫的时候对utf-8页面的中的中文进行处理时常遇到问题，提示如下：</p><p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1…</p><p>是因为系统默认都为ascii编码，而ascii编码不支持中文，解决方法如下：</p><p>设置系统编码为utf-8或者gbk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)  #将默认的ASCII码改为UTF-8编码</span><br></pre></td></tr></table></figure><h2 id="判断编码格式"><a href="#判断编码格式" class="headerlink" title="判断编码格式"></a>判断编码格式</h2><p>直接使用type()函数或者使用chardet()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import chardet</span><br><span class="line">import urllib2</span><br><span class="line">body=urllib2.urlopen(&quot;www.baidu.com&quot;).read()</span><br><span class="line">chardet.detect(body)</span><br></pre></td></tr></table></figure><h1 id="Python字符编码"><a href="#Python字符编码" class="headerlink" title="Python字符编码"></a>Python字符编码</h1><h2 id="源代码编码"><a href="#源代码编码" class="headerlink" title="源代码编码"></a>源代码编码</h2><p>Python的默认编码是ASCII，源代码文件中如果不显示地指定编码的话，将出现语法错误</p><p>SyntaxError: Non-ASCII character ‘\xe7’……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.getdefaultencoding()</span><br><span class="line">&apos;ascii&apos;</span><br></pre></td></tr></table></figure><p>显示指定编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*- </span><br><span class="line">#coding=utf-8</span><br></pre></td></tr></table></figure><h2 id="str、unicode介绍"><a href="#str、unicode介绍" class="headerlink" title="str、unicode介绍"></a>str、unicode介绍</h2><p>在python中和字符串相关的数据类型,分别是str、unicode两种，他们都是basestring的子类，可见str与unicode是两种不同类型的字符串对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> basestring</span><br><span class="line">    /    \ </span><br><span class="line">   /      \</span><br><span class="line">str       unicode</span><br></pre></td></tr></table></figure><p>对于同一个汉字“好”，用str表示时，它对应的就是utf-8编码的’\xe5\xa5\xbd’，而用unicode表示时，他对应的符号就是u’\u597d’，与u”好”是等同的。需要补充一点的是，str类型的字符其具体的编码格式是UTF-8还是GBK，还是其他格式，根据操作系统相关。比如在Windows系统中，cmd命令行中显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#windows终端</span><br><span class="line">&gt;&gt;&gt; a=&apos;好&apos;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;\xba\xc3&apos;</span><br></pre></td></tr></table></figure><p>在Linux系统的命令行中显示的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#linux终端</span><br><span class="line">&gt;&gt;&gt; a=&apos;好&apos;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;\xe5\xa5\xbd&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; b=u&apos;好&apos;</span><br><span class="line">&gt;&gt;&gt; type(b)</span><br><span class="line">&lt;type &apos;unicode&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">u&apos;\u597d&apos;</span><br></pre></td></tr></table></figure><h2 id="str与unicode的转换"><a href="#str与unicode的转换" class="headerlink" title="str与unicode的转换"></a>str与unicode的转换</h2><p>这两种类型的字符串类型之间的转换就是靠这两个方法decode和encode<br><img src="/Users/longhui.he/GithubBlog/source/upload_image/2018-04-01/unicode.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#从str类型转换到unicode</span><br><span class="line">s.decode(encoding)   =====&gt;  &lt;type &apos;str&apos;&gt; to &lt;type &apos;unicode&apos;&gt;</span><br><span class="line">#从unicode转换到str</span><br><span class="line">u.encode(encoding)   =====&gt;  &lt;type &apos;unicode&apos;&gt; to &lt;type &apos;str&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c = b.encode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; type(c)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&apos;\xe5\xa5\xbd&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d = c.decode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; type(d)</span><br><span class="line">&lt;type &apos;unicode&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">u&apos;\u597d&apos;</span><br></pre></td></tr></table></figure><p>这个’\xe5\xa5\xbd’就是unicode u’好’通过函数encode编码得到的UTF-8编码的str类型的字符串。反之亦然，str类型的c通过函数decode解码成unicode字符串d</p><h2 id="工厂方法str-与unicode"><a href="#工厂方法str-与unicode" class="headerlink" title="工厂方法str()与unicode()"></a>工厂方法str()与unicode()</h2><p>str(s)和unicode(s)是两个工厂方法，分别返回str字符串对象和unicode字符串对象，str(s)是s.encode(‘ascii’)的简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s3 = u&quot;你好&quot;</span><br><span class="line">&gt;&gt;&gt; s3</span><br><span class="line">u&apos;\u4f60\u597d&apos;</span><br><span class="line">&gt;&gt;&gt; str(s3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>unicode类型的字符串，str(s3)相当于是执行s3.encode(‘ascii’)因为“你好”两个汉字不能用ascii码来表示，所以就报错了，指定正确的编码：s3.encode(‘gbk’)或者s3.encode(“utf-8”)</p><p>类似的unicode有同样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s4 = &quot;你好&quot;</span><br><span class="line">&gt;&gt;&gt; unicode(s4)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xc4 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>unicode(s4)等效于s4.decode(‘ascii’)，因此要正确的转换就要正确指定其编码：s4.decode(‘gbk’)或者s4.decode(“utf-8”)</p><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><p>乱码本质上是系统编码与所提供字符的编码不一致导致以及字符经过不同编码解码在编码的过程中使用的编码格式不一致，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># encoding: utf-8</span><br><span class="line">&gt;&gt;&gt; a=&apos;好&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;\xe5\xa5\xbd&apos;</span><br><span class="line">&gt;&gt;&gt; b=a.decode(&quot;utf-8&quot;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">u&apos;\u597d&apos;</span><br><span class="line">&gt;&gt;&gt; c=b.encode(&quot;gbk&quot;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&apos;\xba\xc3&apos;</span><br><span class="line">&gt;&gt;&gt; print c</span><br><span class="line">��</span><br></pre></td></tr></table></figure><p>utf-8编码的字符‘好’占用3个字节，解码成Unicode后，如果再用gbk来解码后，只有2个字节的长度了，最后出现了乱码的问题</p><h2 id="终端编码"><a href="#终端编码" class="headerlink" title="终端编码"></a>终端编码</h2><p>在终端执行python脚本时，经常会遇到输出中文乱码，而这往往是因为输出的字符串本身编码与控制台编码不一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#! -*- coding:utf-8 -*-</span><br><span class="line">a=&quot;中文&quot;               #定义一个变量，默认为Str，utf-8编码</span><br><span class="line">print a</span><br><span class="line">print type(a)</span><br><span class="line"></span><br><span class="line">windows控制台输出结果：</span><br><span class="line">浣犲ソ</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line"></span><br><span class="line">linux终端输出结果：</span><br><span class="line">中文</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><p>造成这种差异的原因在于windows控制台为gbk编码，而变量a本身为utf-8编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#! -*- coding:utf-8 -*-</span><br><span class="line">a=&apos;你好&apos;</span><br><span class="line">b=a.decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;)</span><br><span class="line">print b</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>unicode形式的字符串（str类型)，转换成真正的unicode需要使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &apos;id\pythonu003d215903184\u0026index\u003d0\u0026st\u003d52\u0026sid’</span><br><span class="line">&gt;&gt;&gt; print(type(s))</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; s = s.decode(&apos;unicode-escape&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">u&apos;id=215903184&amp;index=0&amp;st=52&amp;sid=95000&amp;i&apos;</span><br><span class="line">&gt;&gt;&gt; print(type(s))</span><br><span class="line">&lt;type &apos;unicode&apos;&gt;</span><br></pre></td></tr></table></figure><ul><li>请尽量在Linux系统上编程，综上我们可以知道linux下较windows，编码问题良好很多。</li><li>python代码内部请全部使用unicode编码，在获取外部内容时，先decode为unicode，向外输出时再encode为Str</li><li>在定义变量或者正则时，也定义unicode字符，如a=u”中文”；res=r””+u”正则”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;秃废是糖，甜到忧伤&lt;/blockquote&gt;
​    Python2 编码问题一直困扰了很久，编程过程中经常因为编码问题报错或出现乱码，现对该知识点进行总结。编码问题主要注意的点：系统默认编码、str与unicode之间转换、windows/linux控制台默认编码。从外界获取的中文一般为str类型，在代码内部建议全部使用unicode编码，在获取外部内容时，先decode为unicode，向外输出时再encode为Str
    
    </summary>
    
    
    
  </entry>
  
</feed>
